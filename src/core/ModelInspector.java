package core;

import annotations.Column;
import annotations.ForeignKey;
import annotations.PrimaryKey;
import annotations.Table;
import customErrors.*;
import enums.ColumnType;
import metadata.ColumnInfo;
import metadata.ReverseRelationMap;
import utils.TimeStampManager;
import validators.ColumnValidator;

import java.lang.annotation.Annotation;
import java.lang.reflect.Field;
import java.util.*;

public abstract class ModelInspector {
    private static final Map<Class<? extends  Model>, List<ColumnInfo>> cache = new HashMap<>();
    private static final Map<Class<? extends Model>, Field> pkFieldMap = new HashMap<>();
    private static final Map<Class<? extends Model>, String> pkNameMap = new HashMap<>();
    private static final Map<Class<? extends Model>, Integer> pkIndexMap = new HashMap<>();
    private static final Map<Class<? extends Model>, List<ColumnInfo>> foreignKeyMap = new HashMap<>();
    private static final Map<Class<? extends Model>, List<ReverseRelationMap>> relatedModels = new HashMap<>();
    private static final Map<Class<? extends Model>, Boolean> doesContainUpdatedAtField = new HashMap<>();

    protected static void annotationPresent(Class<? extends Model> clazz) {
        if (!clazz.isAnnotationPresent(Table.class)) throw new AnnotationNotPresent("Table annotation must be implemented");
    }

    public static String resolveTableName(Class<? extends Model> clazz) {
        annotationPresent(clazz);
        String tableName;
        Table table = clazz.getAnnotation(Table.class);
        if (table.name().isEmpty()) tableName = clazz.getSimpleName();
        else tableName = table.name();

        return tableName;
    }

    public static List<ReverseRelationMap> getRelatedModelsOfClass(Class<? extends Model> clazz) {
        return relatedModels.getOrDefault(clazz, null);
    }

    public static List<ColumnInfo> getForeignKeysOfClass(Class<? extends Model> clazz) {
        return foreignKeyMap.getOrDefault(clazz, null);
    }

    public static String getPkName(Class<? extends Model> clazz) {
        return pkNameMap.getOrDefault(clazz, null);
    }

    public static Field getPkField(Class<? extends Model> clazz) {
        return pkFieldMap.getOrDefault(clazz, null);
    }

    public static int getPkIndex(Class<? extends  Model> clazz) {
        return pkIndexMap.getOrDefault(clazz,-1);
    }

    public static boolean doesTableHaveUpdatedAtField(Class<? extends Model> clazz) {
        return doesContainUpdatedAtField.getOrDefault(clazz, false);
    }

    private static String getForeignKeyName(ColumnInfo info) {
        Field field = info.field();
        ForeignKey fk = info.foreignKey();

        Class<? extends Model> referencedModel = fk.reference();
        String referencedTablePkName = getPkName(referencedModel);

        return field.getName() + "_" + referencedTablePkName;
    }

    public static List<ColumnInfo> getColumns(Class<? extends Model> clazz) {
        if (cache.containsKey(clazz)) return cache.get(clazz);

        int idx = -1;
        List<ColumnInfo> columnInfos = new ArrayList<>();
        Set<String> columnNames = new HashSet<>();

        boolean primaryKeyExists = false;

        for (Field field: clazz.getDeclaredFields()) {

            if (field.isAnnotationPresent(ForeignKey.class)) {
                idx += 1;
                ForeignKey fk = field.getAnnotation(ForeignKey.class);
                if (fk.reference() == null) {
                    throw new ReferencedTableIsNullException("Referenced table cannot be null. ");
                }

                String fkName = getForeignKeyName(new ColumnInfo(field, null, fk));

                Column autoGeneratedColumn = new Column() {
                    @Override public Class<? extends Annotation> annotationType() {return null;}

                    @Override public String name() {return fkName;}

                    @Override public ColumnType type() {return ColumnType.INTEGER;}

                    @Override public boolean nullable() {return fk.nullable();}

                    @Override public boolean unique() {return false;}

                    @Override public int length() {return 0;}

                    @Override public String defaultValue() {return "";}
                };

                if(!foreignKeyMap.containsKey(clazz)) foreignKeyMap.put(clazz, new ArrayList<>());
                if(!relatedModels.containsKey(fk.reference())) relatedModels.put(fk.reference(), new ArrayList<>());

                ColumnInfo columnInfo = new ColumnInfo(field, autoGeneratedColumn, fk);

                String relatedName = fk.relatedName();

                if(relatedName.isEmpty()) relatedName = resolveTableName(fk.reference()).toLowerCase() + "_set";

                ReverseRelationMap reverseRelationMap = new ReverseRelationMap(fk.reference(), getPkName(fk.reference()), relatedName);

                relatedModels.get(fk.reference()).add(reverseRelationMap);
                foreignKeyMap.get(clazz).add(columnInfo);
                columnInfos.add(columnInfo);
            }

            else if (field.isAnnotationPresent(Column.class)) {
                idx += 1;
                Column column = field.getAnnotation(Column.class);

                if(columnNames.contains(column.name())) {
                    throw new MultipleColumnsWithSameNameException("Duplicate column name detected: "
                            + column.name() + " in model " + clazz.getSimpleName());
                }

                columnNames.add(column.name());

                ColumnValidator.validateColumnName(clazz.getSimpleName(), field.getName(), column);

                if (field.isAnnotationPresent(PrimaryKey.class)) {
                    if (primaryKeyExists) throw new MultiplePrimaryKeyException("Model " + clazz.getSimpleName() +
                            " has more than one @PrimaryKey column. Only one is allowed.");

                    pkIndexMap.put(clazz, idx + 1);
                    pkFieldMap.put(clazz, field);
                    pkNameMap.put(clazz, column.name());
                    primaryKeyExists = true;
                }

                if (column.type() == ColumnType.TIMESTAMP) ColumnValidator.
                        validateTimeBasedColumns(clazz.getSimpleName(), field.getName(),column);

                if (TimeStampManager.isUpdatedAt(column)) doesContainUpdatedAtField.put(clazz, true);

                field.setAccessible(true);
                columnInfos.add(new ColumnInfo(field, column, null));
            }
        }

        // throw error if there is no primary key present.
        if (!primaryKeyExists) throw new MissingPrimaryKeyException("Model named " + clazz.getSimpleName() + " misses @PrimaryKey column.");

        // If there is no columns throw custom error.
        if (columnInfos.isEmpty()) {
            throw new MissingColumnsException("No columns to insert in the model named " + clazz.getSimpleName());
        }

        cache.put(clazz, columnInfos);

        return columnInfos;
    }
}
