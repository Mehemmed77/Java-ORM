package core;

import annotations.Column;
import annotations.ForeignKey;
import annotations.PrimaryKey;
import customErrors.*;
import enums.ColumnType;
import manager.Related;
import metadata.ColumnInfo;
import metadata.PrimaryKeyUtils;
import metadata.RelationMeta;
import utils.TimeStampManager;
import validators.ColumnValidator;

import java.lang.annotation.Annotation;
import java.lang.reflect.Field;
import java.util.*;

import static core.ModelInspector.resolveTableName;

public class ModelParser {

    private final Class<? extends Model> clazz;
    private PrimaryKeyUtils pkUtil;
    private boolean hasUpdatedAt = false;
    private final List<ColumnInfo> foreignKeys = new ArrayList<>();
    private final Map<Class<? extends Model>, List<RelationMeta>> reverseRelations = new HashMap<>();

    public ModelParser(Class<? extends Model> clazz) {
        this.clazz = clazz;
    }

    public List<ColumnInfo> parse() {
        int idx = -1;
        boolean primaryKeyExists = false;
        List<ColumnInfo> columnInfos = new ArrayList<>();
        Set<String> columnNames = new HashSet<>();

        for (Field field : clazz.getDeclaredFields()) {

            if (field.isAnnotationPresent(ForeignKey.class)) {
                idx++;
                ForeignKey fk = field.getAnnotation(ForeignKey.class);
                if (fk.reference() == null) {
                    throw new ReferencedTableIsNullException("Referenced table cannot be null.");
                }

                String fkName = generateForeignKeyName(field, fk);

                ColumnInfo columnInfo = getColumnInfo(field, fkName, fk);

                foreignKeys.add(columnInfo);
                columnInfos.add(columnInfo);

                String relatedName = fk.relatedName().isEmpty()
                        ? resolveTableName(clazz).toLowerCase() + "_set"
                        : fk.relatedName();

                reverseRelations.putIfAbsent(fk.reference(), new ArrayList<>());

                reverseRelations.get(fk.reference()).add(new RelationMeta( clazz, columnInfo.column().name(), relatedName, fk.reference()));
            }

            else if (field.isAnnotationPresent(Column.class)) {
                idx++;
                Column column = field.getAnnotation(Column.class);

                if (columnNames.contains(column.name())) {
                    throw new MultipleColumnsWithSameNameException("Duplicate column name: " + column.name());
                }

                columnNames.add(column.name());
                ColumnValidator.validateColumnName(clazz.getSimpleName(), field.getName(), column);

                if (field.isAnnotationPresent(PrimaryKey.class)) {
                    if (primaryKeyExists) {
                        throw new MultiplePrimaryKeyException("More than one @PrimaryKey found in " + clazz.getSimpleName());
                    }

                    primaryKeyExists = true;

                    pkUtil = new PrimaryKeyUtils(field, column.name(), idx + 1);
                }

                if (column.type() == ColumnType.TIMESTAMP) {
                    ColumnValidator.validateTimeBasedColumns(clazz.getSimpleName(), field.getName(), column);
                }

                if (TimeStampManager.isUpdatedAt(column)) {
                    hasUpdatedAt = true;
                }

                field.setAccessible(true);
                columnInfos.add(new ColumnInfo(field, column, null));
            }
        }

        if (!primaryKeyExists) {
            throw new MissingPrimaryKeyException("No @PrimaryKey found in " + clazz.getSimpleName());
        }

        if (columnInfos.isEmpty()) {
            throw new MissingColumnsException("No valid columns found in " + clazz.getSimpleName());
        }

        return columnInfos;
    }

    private static ColumnInfo getColumnInfo(Field field, String fkName, ForeignKey fk) {
        Column autoGeneratedColumn = new Column() {
            @Override public Class<? extends Annotation> annotationType() { return null; }
            @Override public String name() { return fkName; }
            @Override public ColumnType type() { return ColumnType.INTEGER; }
            @Override public boolean nullable() { return fk.nullable(); }
            @Override public boolean unique() { return false; }
            @Override public int length() { return 0; }
            @Override public String defaultValue() { return ""; }
        };

        return new ColumnInfo(field, autoGeneratedColumn, fk);
    }

    private String generateForeignKeyName(Field field, ForeignKey fk) {
        String referencedPk = ModelCache.pkUtilMap.get(fk.reference()).pkName();
        return field.getName() + "_" + referencedPk;
    }

    public PrimaryKeyUtils getPkUtil() {
        return pkUtil;
    }

    public boolean doesHaveUpdatedAt() {
        return hasUpdatedAt;
    }

    public List<ColumnInfo> getForeignKeys() {
        return foreignKeys;
    }

    public Map<Class<? extends Model>, List<RelationMeta>> getReverseRelations() {
        return reverseRelations;
    }
}
